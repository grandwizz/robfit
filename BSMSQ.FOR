CPROCESS DIRECTIVE('*VDIR:')
      SUBROUTINE SMSQ(CHI,CHB,CHL,PC,PPCC,A,FR,CONS,SM,NT,NW)
      IMPLICIT REAL*8 (A-H,O-Z)
C      REAL*4 CHI,CHB,CHL,PC,FR,CONS,SM
C *** PPCC AND A MUST BE REAL*8.  THE OTHER ARGUMENTS CAN BE
C *** DECLARED REAL*4 AND THE ROUTINE WILL STILL WORK
C THE ROUTINE FINDS THE NECESSARY CHANGES IN CONS FOR THE NEW
C VALUE OF CHI TO BE EQUAL TO FR*CHI
C CHI IS THE CURRENT VALUE OF CHI (THE QUANTITIY BEING MINIMIZED)
C CHB IS THE VALUE PREDICTED FOR CHI ON THE LAST CALL TO SMSQ
C CHL IS THE LAST VALUE OF CHI, SM IS A VECTOR CONTAINING THE
C RELATIVE SMOOTHING FOR EACH CONSTANT IN THE VECTOR CONS.
C PC IS THE SET OF FIRST DERIVATIVES OF CHI WITH RESPECT TO THE CONSTANT
C PPCC IS THE SET OF SECOND DERIVS (PPCC(I+J*(J-1)/2) FOR I < J)
C STORED IN PACKED FORM, SEE SMINV
C NOTE THAT WHEN CHB=CHL, THE ROUTINE CAN GET NO LOWER
C NT IS THE NUMBER OF CONSTANTS.  PPCC AND AM ARE UPPER TRIANGLE
C  NW DECIDES WHAT TO WRITE
      SAVE NTO,SPC,SPPCC,SCONS,AS
      DIMENSION CONS(1),SM(1),PC(1),PPCC(1),A(1)
     # ,BB(60),B(60),SPC(60),SPPCC(1830),SCONS(60),SMT(60)
C *** THE ABOVE MUST BE DIMENSIONED NT OR LARGER
      DATA X0,X1,X2,AS/3*0.D0,-1.E0/
      DATA NTO/0/,TOL/1.D-6/
      NDT=NT*(NT+1)/2
      IFL=0
      IRT=0
      IAB=0
      QB=1.D0
      ILEFT=0
      ICYCLE=0
       IAA=0
        DO 3 I=1,NT
3       SM(I)=DEXP(.5*DLOG(SM(I)))
      IF(NT.GT.60)GO TO 2500
      IF(NT.NE.NTO)THEN
        NTO=NT
        CHB=1.D33
        CHL=1.D34
C       DO 4 I=1,NT
C4       SM(I)=1
C        FR=.999
C        PRINT'(8E10.3)',(SM(I),I=1,NT)
      ENDIF
      AS=DMAX1(DMIN1(AS+2,75D0),-100D0)
C SAVE THE LAST SET OF COEFFS IF CHI<CHL
      IF(NW.GE.1)WRITE(*,'(A,3G20.7)')' CHI,CHB,CHL',CHI,CHB,CHL
      IF(CHI.GT.CHL)GO TO 10
      IF(1.000001*CHI.LT.CHL)IR=0
      DO 8 I=1,NT
      SCONS(I)=CONS(I)
8     SPC(I)=PC(I)
      DO 9 I=1,NDT
9     SPPCC(I)=PPCC(I)
      IF((CHI-CHB)/(CHL-CHI+1.E-6).GT..1)FR=.1*(9*FR+1)
      IF((CHI-CHB)/(CHL-CHI+1.E-6).GT.1.)GOTO 20
      FR=DMAX1(1.D-2,FR*FR*FR)
      GOTO 20
10      CONTINUE
C RESET TO THE BEST COEFFS (BEWARE THE ROUTINE MUST HAVE RUN BEFORE)
C *** RECALCULATE SMOOTHERS USING LAM*S=PC(L)-SPC(L)-SUMI SPPCC(LI)*BB(I)
        DO 12 L=1,NT
        SMT(L)=PC(L)-SPC(L)
        DO 12 I=1,NT
        LI=KIJ(L,I)
12      SMT(L)=SMT(L)-SPPCC(LI)*BB(I)
C *** FIND LARGEST SM
        SML=0
        DO 14 I=1,NT
        SMT(I)=DABS(SMT(I)/DMAX1(DABS(BB(I)),1D-12))
14      SML=DMAX1(SML,SMT(I))
        DO 16 I=1,NT
16      SM(I)=.99*DMAX1(1.D-24,(SMT(I)/SML)*1.D24)+.01*SM(I)
        IF(NW.GE.2)PRINT'(8E10.3)',(SM(I),I=1,NT)
      AS=DMIN1(AS+17.D0,75D0)
      FR=.25*(3.+CHB/CHL)
      IR=IR+1
      CHI=CHL
      DO 18 I=1,NT
      CONS(I)=SCONS(I)
      BB(I)=CONS(I)
18    PC(I)=SPC(I)
      DO 19 I=1,NDT
19    PPCC(I)=SPPCC(I)
      IF(NW.GE.1)WRITE(*,191)IR
191     FORMAT(' IR=',I5)
      IF(IR.GT.20)THEN
        CHB=CHI
        RETURN
      ENDIF
20      CONTINUE
      IF(NW.GE.2)WRITE(*,173)FR
173     FORMAT(' FR=',E10.3)
      CHB=CHI
25      DE=DEXP(AS)
      KI=0
      DO 32 I=1,NT
      KI=KI+I
32      PPCC(KI)=PPCC(KI)+SM(I)*DE
38    CONTINUE
      CALL GSOLVE(PPCC,A,PC,B,NT)
      KI=0
      DO 40 I=1,NT
      KI=KI+I
40    PPCC(KI)=PPCC(KI)-SM(I)*DE
      ICYCLE=ICYCLE+1
C *** NOTE THAT B HERE IS THE SAME AS X IN GSOLVE
52      AJP=CHI
      IF(NW.GE.4)WRITE(*,10017)(B(I),I=1,NT)
      KI=0
      DO 60 K=1,NT
      KI=KI+K
      IF(DABS(B(K)).GT.1.D10)B(K)=DSIGN(1.D10,B(K))
      AJP=AJP+B(K)*(PC(K)+0.5*PPCC(KI)*B(K))
      IF(K.EQ.1)GOTO 60
      KM=K-1
      KT=KI-K
      DO 55 M=1,KM
      KT=KT+1
55      AJP=AJP+PPCC(KT)*B(M)*B(K)
60      CONTINUE
      IF(NW.GE.3)WRITE(*,104)AJP
104     FORMAT(' AJP=',E20.12)
C ****** AJP WAS CALCULATED ABOVE, WILL BE TESTED BELOW *************
C **** IF WE CAN FIND AJP < FR*CHI, WE CAN INTERPOLATE IN AS TO
C **** FIND A VALUE FOR WHICH AJP=FR*CHI, IFL = 1 INDICATES THIS CONDITI
      DT=AJP/DMAX1(1.D-35,CHI)
      IF(NW.GE.3)WRITE(*,105)DT
105     FORMAT(' DT=',E20.12)
      IF(DT.GE.FR)IAB=1
      IF(DT.LT.FR)IFL=1
      IF(DT-1.E0.LT.1.E-7)GOTO 1000
      IF(NW.GE.2)WRITE(*,109)AJP,AS
109     FORMAT(' THE MATRIX INVERSION APPEARS WRONG, AJP,AS',2E15.6)
C *********** THIS INVERSION IS WRONG, BUT A PREVIOUS ONE WAS RIGHT THU
      IF(NW.GE.3)WRITE(*,3421)IAA,AS
3421    FORMAT(' IAA,AS',I5,E20.6)
      IF(IAA.EQ.1)GOTO 1000
C ********** THIS INVERSION IS WRONG AND WE HAVE NEVER HAD A CORRECT ONE
      IF(AS.GE.76.)THEN
      IR=I+1
      GOTO 10
      ENDIF
115     AS=AS+3.
      GOTO 25
120     CONTINUE
C FINDING X'S ON EACH SIDE OF FR*CHI
      IF(ICYCLE.GT.50)AS=DMIN1(75.D0,AS+30.E0)
      IF(ICYCLE.GT.30.OR.DABS((AJP-FR*CHI)/CHI).LT.TOL)GOTO 3117
      IF(AJP.GT.FR*CHI)GOTO 130
      IRT=IRT+1
       ILEFT=0
      AR=AS
      QR=AJP/CHI-FR
      GOTO 140
130     AL=AS
      QL=AJP/CHI-FR
      IRT=0
      ILEFT=ILEFT+1
140     X0=X1
      X1=X2
      IF(IFL*IAB.EQ.0)GOTO 1150
      IF(QB.GT.1.-FR)GOTO 115
      IF(DABS((AR-AL)).LT..1E-5)GOTO 3117
      AS=AL-QL*(AR-AL)/(QR-QL)
      X2=AS
      IF(NW.GE.2)WRITE(*,102)AL,QL,AR,QR,AS
102     FORMAT(' AL,QL',2E15.6,' AR,QR',2E15.6,' AS=',E15.6)
      IF(IRT.LT.2.AND.ILEFT.LT.2)GOTO 25
C AITKENS EXTRAPOLATION
      ALPHA=(X1**2-X0*X2)*(2.*X1-X2-X0)/((2.*X1-X2-X0)**2+1.E-37)
      IF(ALPHA.LT.AL.AND.AL.LT.AR)ALPHA=.5*(AL+AR)
      IF(ALPHA.GT.AL.AND.AL.GT.AR)ALPHA=.5*(AL+AR)
      IF(ALPHA.LT.AR.AND.AR.LT.AL)ALPHA=.5*(AL+AR)
      IF(ALPHA.GT.AR.AND.AR.GT.AL)ALPHA=.5*(AL+AR)
      IF(DABS((ALPHA-AR)/(AR-AL)).LT..1E-1.OR.DABS((ALPHA-AL)/(AR-AL))
     # .LT..1E-1)ALPHA=.5*(AL+AR)
      AS=ALPHA
      IF(NW.GE.2)WRITE(*,103)AS
103   FORMAT(' AITKENS EXTRAPOLATION, AS',E15.6)
      ILEFT=0
      IRT=0
      GOTO 25
C ********* WE HAVE FOUND 0 < AJP < CHI ***********************
C ********* AND WE WANT TO SAVE THE BEST SET OF B'S **********
1000  QC=DABS(AJP/CHI-FR)
      IF(IAA.EQ.0)GOTO 1050
      IF(QC.GT.QB)GOTO 1120
1050  CHB=AJP
      IAA=1
      QB=QC
      ASB=AS
      IF(NW.GE.2)WRITE(*,117)QB,AJP,AS
117     FORMAT(' QB,AJP,AS',3E15.6)
      DO 1115 I=1,NT
1115    BB(I)=B(I)
      IF(QB.LT.TOL)GOTO 3117
1120    GOTO 120
C ********* TRY AGAIN WITH MORE OR LESS SMOOTHING **********
1150    AS=AS-4.0
      IF(IR.GT.1)AS=.5*(AS+ASB)
      IF(IAB.EQ.0)AS=AS+8.
      IF(AS.LE.-100.)GOTO 3117
      IF(AS.GE.76.)GOTO 3117
      GOTO 25
C ****************** EXITING WITH THE BEST COEFF'S FOUND ***********
3117    CONTINUE
      CHL=CHI
      DO 3119 I=1,NT
3119    CONS(I)=CONS(I)+BB(I)
      IF(NW.GE.3)WRITE(*,10017)(BB(I),I=1,NT)
10017   FORMAT(1X,6E13.6)
      IF(NW.GE.3)WRITE(*,10018)QB
10018   FORMAT(' THE FINAL QB IS',E20.12)
      IF(NW.GE.2)PRINT'(A,G11.4)',' FINAL AS IS',AS
      RETURN
2500    WRITE(*,4367)NT
4367    FORMAT(' NT OF',I5,' IS TOO LARGE FOR THE'/
     # ' DIMENSION OF B AND BB AND ALSO TERMS IN GSOLVE')
      STOP
      END
      SUBROUTINE SMINV(AP,N,IFL)
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION AP(1)
C *** THIS ROUTINE BEGINS IN LINPACK CHAPTER 3 - POSITIVE
C *** DEFINITE SYMMETRIC MATRICES
C *** IN OUR CASE (CURVE FITTING) WE CAN ALWAYS WRITE THE APPROXIMATE
C *** FUNCTION AS SUM C*SJ(XI).  IF WE THEN FORM X**2 = SUM ON I
C *** OF SUM ON J (CJ*SJ(XI))**2 WE FIND X**2 = SUM ON K CK *
C *** SUM ON J CJ * AJK WHERE AJK IS SUM ON I SJ(XI)*SK(XJ), THE
C *** POSITIVE DEFINITE SYMMETRIC MATRIX OF INTEREST HERE
C
C *** AP IS A PACKED MATRIX AS IN THE FOLLOWING
C *** K=0
C     DO 20 J=1,N
C     DO 20 I=1,J
C     K=K+1
C     AP(K)=A(I,J)
C 20  CONTINUE
      IFL=0
      JJ=0
      DO 30 J=1,N
      S=0
      KJ=JJ
      KK=0
      IF(J.LT.2)GOTO 20
      JM1=J-1
      DO 10 K=1,JM1
      KJ=KJ+1
      T=AP(KJ)
      KM1=K-1
      IF(KM1.LT.1)GOTO 8
      IF(KM1.GT.32)GOTO 6
C*VDIR: ASSUME COUNT(5)
      DO 5 I=1,KM1
5     T=T-AP(I+KK)*AP(I+JJ)
      GOTO 8
6     CONTINUE
      CALL TSUM(T,AP,KM1,KK,JJ)
8     KK=KK+K
      T=T/AP(KK)
      AP(KJ)=T
        IF(T.GT.1.D75.OR.T.LT.-1.D75)THEN
          PRINT*,' AP(KK)=',KK,AP(KK)
          T=DMAX1(-1.D75,DMIN1(1.D75,T))
          READ(*,*)ITEST
        ENDIF
      S=S+T*T
10    CONTINUE
20    CONTINUE
      JJ=JJ+J
      SMT=DMAX1(S,AP(JJ))
      DIFF=AP(JJ)-S
      IF(DIFF.GT.1.D-10*SMT)GOTO 25
C      WRITE(*,1975)J,AP(JJ),S
1975    FORMAT(' POS DEF QUANT LE 0. J=',I5,' AP(JJ)=',E10.3,
     # ' S=',E10.3)
C *** FIX IS MORE SMOOTHING FOR A(J,J)
      IFL=-1
      DIFF=1.D30
25    AP(JJ)=DSQRT(DIFF)
30    CONTINUE
C *** NEXT WE CONSTRUCT THE INVERSE MATRIX
      KK=0
      DO 100 K=1,N
      K1=KK
      KK=KK+K
      AP(KK)=1/AP(KK)
      T=-AP(KK)
      KM=K-1
      IF(KM.LE.0)GOTO 86
      DO 85 I=1,KM
85    AP(I+K1)=T*AP(I+K1)
86    KP1=K+1
      J1=KK
      KJ=KK+K
      IF(N.LT.KP1)GOTO 90
      DO 80 J=KP1,N
      T=AP(KJ)
      AP(KJ)=0
      IF(K.GT.32)GOTO 72
C*VDIR: ASSUME COUNT(5)
      DO 70 I=1,K
70    AP(J1+I)=AP(J1+I)+T*AP(K1+I)
       GOTO 77
72    CONTINUE
      CALL VSUM(AP,AP,T,K,K1,J1)
77    J1=J1+J
      KJ=KJ+J
80    CONTINUE
90    CONTINUE
100     CONTINUE
      JJ=0
      DO 130 J=1,N
      J1=JJ
      JJ=JJ+J
      JM1=J-1
      K1=0
      KJ=J1+1
      IF(JM1.LT.1)GOTO 120
      DO 110 K=1,JM1
      T=AP(KJ)
       IF(K.GT.32)GOTO 107
C*VDIR: ASSUME COUNT(5)
      DO 105 I=1,K
105     AP(I+K1)=AP(I+K1)+T*AP(I+J1)
         GOTO 117
107     CONTINUE
      CALL VSUM(AP,AP,T,K,J1,K1)
117   K1=K1+K
      KJ=KJ+1
110     CONTINUE
120     CONTINUE
      T=AP(JJ)
      DO 125 I=1,J
125      AP(I+J1)=T*AP(I+J1)
C ABOVE LINE ORIGINALLY HAD A CALL TO FUNC ANOV
130     CONTINUE
140     CONTINUE
      RETURN
      END
C     FUNCTION ANOV(X,Y)
C     IMPLICIT REAL*8 (A-H,O-Z)
C     EQUIVALENCE (IX,XT),(IY,YT)
C     ANOV='FFFF7CFF'X*DSIGN(1.D0,X)*DSIGN(1.D0,Y)
C     XT=X
C     YT=Y
C     IF((IX.AND.'7F80'X)+(IY.AND.'7F80'X).LT.'BC80'X)
C    #  ANOV=XT*YT
C     ANOV=XT*YT
C     RETURN
C     END
      SUBROUTINE GSOLVE(A,AM,B,X,NT)
      IMPLICIT REAL*8 (A-H,O-Z)
C *** SOLVES AX=-B IN CASES WHERE THE MATRIX CAN BE INVERTED CHEAPLY
C *** AND ACCURATELY WITH NO PROBLEMS
      DIMENSION A(1),AM(1),B(1),X(1)
      NTD=NT*(NT+1)/2
      DO 10 I=1,NTD
10    AM(I)=A(I)
      CALL SMINV(AM,NT,IFL)
      CALL SMMULT(AM,B,X,NT)
      DO 20 I=1,NT
20    X(I)=-X(I)
      RETURN
      END
      SUBROUTINE SMMULT(A,B,C,N)
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION A(1),B(1),C(1)
C *** FOR PACKED MATRICES C(N)=A(N*(N+1)/2)*B(N)
      DO 10 I=1,N
10    C(I)=0
      K=0
      DO 20 I=1,N
      IM=I-1
      DO 15 J=1,IM
      K=K+1
      C(I)=C(I)+A(K)*B(J)
15    C(J)=C(J)+A(K)*B(I)
      K=K+1
20    C(I)=C(I)+A(K)*B(I)
      RETURN
      END
      FUNCTION KIJ(I1,I2)
C     WRITE(*,'(A,2I5)')' IN KIJ I1,I2',I1,I2
      I=MIN0(I1,I2)
      J=MAX0(I1,I2)
      KIJ=(J*(J-1)/2)+I
      RETURN
      END
      SUBROUTINE VSUM(AP,ATEMP,T,K,K1,J1)
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION AP(1),ATEMP(1)
      DO 75 I=1,K
75    AP(J1+I)=AP(J1+I)+T*ATEMP(K1+I)
      RETURN
      END
      SUBROUTINE TSUM(T,AP,KM1,KK,JJ)
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION AP(1)
      DO 7 I=1,KM1
7     T=T-AP(I+KK)*AP(I+JJ)
      RETURN
      END
